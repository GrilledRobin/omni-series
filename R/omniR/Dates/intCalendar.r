#---------------------------------------------------------------------------------------------------------------------------------------#
#100.   Introduction.                                                                                                                   #
#---------------------------------------------------------------------------------------------------------------------------------------#
#   |This function is intended to split the gregorian calendar by the provided [interval], to facilitate the [interval]-related         #
#   | functions, such as [intnx] and [intck]                                                                                            #
#---------------------------------------------------------------------------------------------------------------------------------------#
#200.   Glossary.                                                                                                                       #
#---------------------------------------------------------------------------------------------------------------------------------------#
#   |100.   Parameters.                                                                                                                 #
#   |-----------------------------------------------------------------------------------------------------------------------------------#
#   |interval    :   Either character string or a valid [list] holding items generated by function [omniR$Dates$getDateIntervals]       #
#   |                 value, while the functions raises error if it is NOT provided.                                                    #
#   |                 [<str>       ]           See definition of [omniR$Dates$getDateIntervals] for accepted values                     #
#   |                 [<list>      ]           Dictionary generated by above function                                                   #
#   |cal_bgn     :   Beginning of the dedicated calendar BEFORE being split by the interval                                             #
#   |cal_end     :   End of the dedicated calendar BEFORE being split by the interval                                                   #
#   |daytype     :   Type of days for the calculation                                                                                   #
#   |                 [C           ] <Default> Calendar Days                                                                            #
#   |                 [W           ]           Working Days                                                                             #
#   |                 [T           ]           Trading Days                                                                             #
#   |col_rowidx  :   Column name representing the record index within the whole output calendar                                         #
#   |                Column attributes:                                                                                                 #
#   |                 [dtype       ][numeric     ]                                                                                      #
#   |                Valid inputs:                                                                                                      #
#   |                 [.ical_row.  ] <Default> The default column name                                                                  #
#   |                 [<str>       ]           Any valid character string as column name                                                #
#   |col_period  :   Column name representing the [period] in the output calendar                                                       #
#   |                Column attributes:                                                                                                 #
#   |                 [dtype       ][numeric     ]                                                                                      #
#   |                Valid inputs:                                                                                                      #
#   |                 [.ical_prd.  ] <Default> The default column name                                                                  #
#   |                 [<str>       ]           Any valid character string as column name                                                #
#   |col_prdidx  :   Column name representing the record index within each [period] in the output calendar                              #
#   |                Column attributes:                                                                                                 #
#   |                 [dtype       ][numeric     ]                                                                                      #
#   |                Valid inputs:                                                                                                      #
#   |                 [.ical_rprd. ] <Default> The default column name                                                                  #
#   |                 [<str>       ]           Any valid character string as column name                                                #
#   |col_weekday :   Column name representing the record flag of [weekday] in the output calendar                                       #
#   |                Column attributes:                                                                                                 #
#   |                 [dtype       ][logical     ]                                                                                      #
#   |                Valid inputs:                                                                                                      #
#   |                 [.ical_wday. ] <Default> The default column name                                                                  #
#   |                 [<str>       ]           Any valid character string as column name                                                #
#   |kw_cal      :   Arguments for instantiating the class [omniPy.Dates.UserCalendar] if [cal] is NOT provided                         #
#   |                 [<Default>   ] <Default> Use the default arguments for [UserCalendar]                                             #
#   |-----------------------------------------------------------------------------------------------------------------------------------#
#   |900.   Return Values by position.                                                                                                  #
#   |-----------------------------------------------------------------------------------------------------------------------------------#
#   |<DataFrame> :   Calendar literally grouped by the provided interval                                                                #
#---------------------------------------------------------------------------------------------------------------------------------------#
#300.   Update log.                                                                                                                     #
#---------------------------------------------------------------------------------------------------------------------------------------#
#   | Date |    20211006        | Version | 1.00        | Updater/Creator | Lu Robin Bin                                                #
#   |______|____________________|_________|_____________|_________________|_____________________________________________________________#
#   | Log  |Version 1.                                                                                                                  #
#   |______|____________________________________________________________________________________________________________________________#
#   |___________________________________________________________________________________________________________________________________#
#   | Date |    20211204        | Version | 2.00        | Updater/Creator | Lu Robin Bin                                                #
#   |______|____________________|_________|_____________|_________________|_____________________________________________________________#
#   | Log  |[1] Now return the same data frame for all [itype]s, to unify the calculation for all [span]s in the related functions      #
#   |______|____________________________________________________________________________________________________________________________#
#   |___________________________________________________________________________________________________________________________________#
#   | Date |    20221017        | Version | 2.10        | Updater/Creator | Lu Robin Bin                                                #
#   |______|____________________|_________|_____________|_________________|_____________________________________________________________#
#   | Log  |[1] Fixed a bug when Saturday is Workday and the requested interval is Workweek                                             #
#   |______|____________________________________________________________________________________________________________________________#
#   |___________________________________________________________________________________________________________________________________#
#   | Date |    20230114        | Version | 2.20        | Updater/Creator | Lu Robin Bin                                                #
#   |______|____________________|_________|_____________|_________________|_____________________________________________________________#
#   | Log  |[1] Introduce a function [match.arg.x] to enable matching args after mutation, e.g. case-insensitive match                  #
#   |______|____________________________________________________________________________________________________________________________#
#   |___________________________________________________________________________________________________________________________________#
#   | Date |    20230618        | Version | 2.30        | Updater/Creator | Lu Robin Bin                                                #
#   |______|____________________|_________|_____________|_________________|_____________________________________________________________#
#   | Log  |[1] Fixed a bug when [itype == 't'] and [span > 1], the calculation results to NA when period reaches 0                     #
#   |______|____________________________________________________________________________________________________________________________#
#---------------------------------------------------------------------------------------------------------------------------------------#
#400.   User Manual.                                                                                                                    #
#---------------------------------------------------------------------------------------------------------------------------------------#
#   |See the [Full Test Program] section                                                                                                #
#---------------------------------------------------------------------------------------------------------------------------------------#
#500.   Dependent Facilities.                                                                                                           #
#---------------------------------------------------------------------------------------------------------------------------------------#
#   |100.   Dependent Modules                                                                                                           #
#   |-----------------------------------------------------------------------------------------------------------------------------------#
#   |   |magrittr, vctrs, rlang, dplyr, tidyselect                                                                                      #
#   |-----------------------------------------------------------------------------------------------------------------------------------#
#   |300.   Dependent user-defined functions                                                                                            #
#   |-----------------------------------------------------------------------------------------------------------------------------------#
#   |   |omniR$Dates                                                                                                                    #
#   |   |   |getDateIntervals                                                                                                           #
#   |   |   |UserCalendar                                                                                                               #
#   |   |-------------------------------------------------------------------------------------------------------------------------------#
#   |   |omniR$AdvOp                                                                                                                    #
#   |   |   |match.arg.x                                                                                                                #
#---------------------------------------------------------------------------------------------------------------------------------------#

#001. Append the list of required packages to the global environment
#Below expression is used for easy copy-paste from raw text strings instead of quoted ones.
lst_pkg <- deparse(substitute(c(
	magrittr, vctrs, rlang, dplyr, tidyselect
)))
#Quote: https://www.regular-expressions.info/posixbrackets.html?wlr=1
lst_pkg <- paste0(lst_pkg, collapse = '')
lst_pkg <- gsub('[[:space:]]', '', lst_pkg, perl = T)
lst_pkg <- gsub('^c\\((.+)\\)', '\\1', lst_pkg, perl = T)
lst_pkg <- unlist(strsplit(lst_pkg, ',', perl = T))
options( omniR.req.pkg = base::union(getOption('omniR.req.pkg'), lst_pkg) )

library(magrittr)

intCalendar <- function(
	interval
	,cal_bgn
	,cal_end
	,daytype = c('C','W','T')
	,col_rowidx = '.ical_row.'
	,col_period = '.ical_prd.'
	,col_prdidx = '.ical_rprd.'
	,col_weekday = '.ical_wday.'
	,kw_cal = formals(UserCalendar$public_methods$initialize)[
		!(names(formals(UserCalendar$public_methods$initialize)) %in% c('dateBgn', 'dateEnd', 'clnBgn', 'clnEnd'))
	]
){
	#010. Parameters
	#[Quote: https://stackoverflow.com/questions/15595478/how-to-get-the-name-of-the-calling-function-inside-the-called-routine ]
	LfuncName <- deparse(sys.call()[[1]])
	#If above statement cannot find the name correctly, this function must have been called via [do.call] or else,
	# hence we need to traverse one layer above current one and extract the first argument of that call.
	if (grepl('^function.+$',LfuncName[[1]],perl = T)) LfuncName <- gsub('^.+?\\((.+?),.+$','\\1',deparse(sys.call(-1)),perl = T)[[1]]
	#[Quote: https://www.r-bloggers.com/doing-away-with-%e2%80%9cunknown-timezone%e2%80%9d-warnings/ ]
	#[Quote: Search for the TZ value in the file: [<R Installation>/share/zoneinfo/zone.tab]]
	if (nchar(Sys.getenv('TZ')) == 0) Sys.setenv(TZ = 'Asia/Shanghai')
	isDict <- function(x) vctrs::vec_is_list(x) && rlang::is_dictionaryish(x)

	#012. Handle the parameter buffer
	daytype <- match.arg.x(daytype, arg.func = toupper)

	#020. Remove possible items that conflict the internal usage from the [kw_cal]
	kw_cal_fnl <- kw_cal[!(names(kw_cal) %in% c('dateBgn', 'dateEnd', 'clnBgn', 'clnEnd'))]

	#040. Get the attributes for the requested time interval
	if (isDict(interval)) {
		dict_attr <- interval
	} else {
		#The result of below function is [list], while current input has only one element, hence we use the first among the result
		dict_attr <- getDateIntervals(interval)[[1]]
	}

	#050. Local parameters
	if (dict_attr[['itype']] %in% c('d', 'dt')) {
		col_out <- 'D_DATE'
	} else {
		col_out <- 'T_TIME'
	}

	#057. Column names for different request types for dates
	dict_adjcol <- c('W' = 'F_WORKDAY', 'T' = 'F_TradeDay')

	#100. Prepare helper functions
	#110. Function to create period indexes and their respective relative date indexes
	h_dateidx <- function(df, firstrec) {
		#001. Create a copy of the input data frame
		rst <- df

		#100. Set the starting date
		rst[['.firstrec.']] <- firstrec
		rst[1, '.firstrec.'] <- T
		rst[[col_period]] <- cumsum(rst[['.firstrec.']])

		#300. Subtract the period beginning by 1 for time calculation
		#[ASSUMPTION]
		#[1] This function is always called when [span > 1]
		#[2] Above condition indicates <name> is not <second>
		#[3] Hence such period starts from 0 instead of 1
		if (dict_attr[['itype']] == 't') {
			rst[[col_period]] <- rst[[col_period]] - 1
		}

		#500. Filter the data by the requested type of days
		if ((dict_attr[['itype']] %in% c('d', 'dt')) & (daytype %in% c('W', 'T'))) {
			rst %<>% dplyr::group_by_at(tidyselect::all_of(col_period)) %>%
				dplyr::mutate(!!rlang::sym(col_prdidx) := cumsum(!!rlang::sym(dict_adjcol[[daytype]]))) %>%
				dplyr::ungroup()
		} else {
			rst %<>% dplyr::group_by_at(tidyselect::all_of(col_period)) %>%
				dplyr::mutate(!!rlang::sym(col_prdidx) := dplyr::row_number()) %>%
				dplyr::ungroup()
		}

		#999. Return the data frame
		return(rst)
	}

	#300. Create the full calendar
	if (dict_attr[['itype']] %in% c('t')) {
		#100. Create the sequence
		#Quote: https://www.geeksforgeeks.org/how-to-create-a-range-of-dates-in-r/
		outRst <- data.frame(seq(cal_bgn, cal_end, by = 1))
		colnames(outRst) <- col_out
	} else {
		#100. Instantiate the User Calendar
		intcal_uc <- do.call(
			UserCalendar$new
			,modifyList(
				list(
					clnBgn = cal_bgn
					,clnEnd = cal_end
				)
				,kw_cal_fnl
			)
		)

		#900. Extract the data frame of the User Calendar
		outRst <- intcal_uc$usrCalendar
	}

	#500. Add necessary columns
	outRst[[col_rowidx]] <- outRst[[col_out]] %>% dplyr::row_number()

	#700. Reshape the calendar for different scenarios
	if (dict_attr[['span']] == 1) {
		#IMPORTANT: This date index may have duplicates
		#100. Reset date index within the entire period for work/trade days
		if ((dict_attr[['itype']] %in% c('d', 'dt')) & (daytype %in% c('W', 'T'))) {
			outRst[[col_rowidx]] <- outRst[[dict_adjcol[[daytype]]]] %>% cumsum()
		}

		#300. Reset date index within the entire period for weekdays
		if (dict_attr[['name']] %in% c('weekday', 'dtweekday')) {
			#500. Mark the dates which are [weekdays]
			outRst[[col_weekday]] <- outRst %>%
				dplyr::mutate_at(col_out, ~1 < lubridate::wday(.) & lubridate::wday(.) < 7) %>%
				dplyr::pull(tidyselect::all_of(col_out))

			if ((dict_attr[['itype']] %in% c('d', 'dt')) & (daytype %in% c('W', 'T'))) {
				outRst[[col_weekday]] <- outRst[[col_weekday]] & outRst[[dict_adjcol[[daytype]]]]
			}

			#900. Correct the default index by all weekdays
			outRst[[col_rowidx]] <- cumsum(outRst[[col_weekday]])
		}

		#800. Create the field of [Period], which is the same as [Row Index] for such case
		outRst[[col_period]] <- outRst[[col_rowidx]]
		outRst[[col_prdidx]] <- 1
	} else if ((dict_attr[['name']] %in% c('week', 'dtweek')) & (daytype %in% c('W', 'T'))) {
		outRst <- h_dateidx(
			outRst
			,outRst[[dict_adjcol[[daytype]]]] & !(outRst[[dict_adjcol[[daytype]]]] %>% dplyr::lag(default = F))
		)
	} else {
		#100. Create intervals for different scenarios
		if (dict_attr[['name']] %in% c('week', 'dtweek')) {
			outRst <- h_dateidx( outRst, lubridate::wday(outRst[[col_out]]) %in% c(1) )
		} else if (dict_attr[['name']] %in% c('tenday', 'dttenday')) {
			outRst <- h_dateidx( outRst, lubridate::day(outRst[[col_out]]) %in% c(1,11,21) )
		} else if (dict_attr[['name']] %in% c('semimonth', 'dtsemimonth')) {
			outRst <- h_dateidx( outRst, lubridate::day(outRst[[col_out]]) %in% c(1,16) )
		} else if (dict_attr[['name']] %in% c('month', 'dtmonth')) {
			outRst <- h_dateidx( outRst, lubridate::day(outRst[[col_out]]) %in% c(1) )
		} else if (dict_attr[['name']] %in% c('qtr', 'dtqtr')) {
			outRst <- h_dateidx(
				outRst
				,(lubridate::day(outRst[[col_out]]) %in% c(1)) & (lubridate::month(outRst[[col_out]]) %in% c(1,4,7,10))
			)
		} else if (dict_attr[['name']] %in% c('semiyear', 'dtsemiyear')) {
			outRst <- h_dateidx(
				outRst
				,(lubridate::day(outRst[[col_out]]) %in% c(1)) & (lubridate::month(outRst[[col_out]]) %in% c(1,7))
			)
		} else if (dict_attr[['name']] %in% c('year', 'dtyear')) {
			outRst <- h_dateidx(
				outRst
				,(lubridate::day(outRst[[col_out]]) %in% c(1)) & (lubridate::month(outRst[[col_out]]) %in% c(1))
			)
		} else if (dict_attr[['name']] %in% c('minute', 'dtminute')) {
			outRst <- h_dateidx( outRst, lubridate::second(outRst[[col_out]]) %in% c(0) )
		} else if (dict_attr[['name']] %in% c('hour', 'dthour')) {
			outRst <- h_dateidx(
				outRst
				,(lubridate::second(outRst[[col_out]]) %in% c(0)) & (lubridate::minute(outRst[[col_out]]) %in% c(0))
			)
		}
	}

	#999. Output
	return(outRst)
}

#[Full Test Program;]
if (FALSE){
	#Simple test
	if (TRUE){
		#010. Load user defined functions
		source('D:\\R\\autoexec.r')

		#100. Create an interval-bound calendar
		cal1 <- intCalendar( 'SEMIMONTH3', '20210501', '20210531', 'w' )
		View(cal1)
	}
}
